{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Injectable, Inject } from '@angular/core';\nimport { __awaiter } from 'tslib';\nimport { getContainerElementAndSetTemplate } from 'single-spa-angular/internals';\nimport { ɵBrowserPlatformLocation, DOCUMENT, PlatformLocation } from '@angular/common';\n\nfunction enableProdMode() {\n  try {\n    // The `enableProdMode` will throw an error if it's called multiple times,\n    // but it may be called multiple times when dependencies are shared.\n    i0.enableProdMode();\n  } catch (_a) {// Nothing to do here.\n  }\n}\n\nlet SingleSpaPlatformLocation = /*#__PURE__*/(() => {\n  class SingleSpaPlatformLocation extends ɵBrowserPlatformLocation {\n    constructor() {\n      super(...arguments); // This is a simple marker that helps us to ignore PopStateEvents\n      // that was not dispatched by the browser.\n\n      this.skipNextPopState = false;\n      this.source = 'Window.addEventListener:popstate';\n    }\n\n    pushState(state, title, url) {\n      this.skipNextPopState = true;\n      super.pushState(state, title, url);\n    }\n\n    replaceState(state, title, url) {\n      this.skipNextPopState = true;\n      super.replaceState(state, title, url);\n    }\n\n    onPopState(fn) {\n      // `Zone.current` will reference the zone that serves as an execution context\n      // to some specific application, especially when `onPopState` is called.\n      const zone = Zone.current; // Wrap any event listener into zone that is specific to some application.\n      // The main issue is `back/forward` buttons of browsers, because they invoke\n      // `history.back|forward` which dispatch `popstate` event. Since `single-spa`\n      // overrides `history.replaceState` Angular's zone cannot intercept this event.\n      // Only the root zone is able to intercept all events.\n      // See https://github.com/single-spa/single-spa-angular/issues/94 for more details\n\n      fn = zone.wrap(fn, this.source);\n\n      const onPopStateListener = event => {\n        // The `LocationChangeEvent` doesn't have the `singleSpa` property, since it's added\n        // by `single-spa` starting from `5.4` version. We need this check because we want\n        // to skip \"unnatural\" PopStateEvents, the one caused by `single-spa`.\n        const popStateEventWasDispatchedBySingleSpa = !!event.singleSpa;\n\n        if (this.skipNextPopState && popStateEventWasDispatchedBySingleSpa) {\n          this.skipNextPopState = false;\n        } else {\n          fn(event);\n        }\n      };\n\n      return super.onPopState(onPopStateListener);\n    }\n\n  }\n\n  /** @nocollapse */\n\n  /** @nocollapse */\n  SingleSpaPlatformLocation.ɵfac = /* @__PURE__ */function () {\n    let ɵSingleSpaPlatformLocation_BaseFactory;\n    return function SingleSpaPlatformLocation_Factory(t) {\n      return (ɵSingleSpaPlatformLocation_BaseFactory || (ɵSingleSpaPlatformLocation_BaseFactory = i0.ɵɵgetInheritedFactory(SingleSpaPlatformLocation)))(t || SingleSpaPlatformLocation);\n    };\n  }();\n  /** @nocollapse */\n\n  /** @nocollapse */\n\n\n  SingleSpaPlatformLocation.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: SingleSpaPlatformLocation,\n    factory: SingleSpaPlatformLocation.ɵfac\n  });\n  return SingleSpaPlatformLocation;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * The `PlatformLocation` class is an \"injectee\" of the `PathLocationStrategy`,\n * which creates `Subject` internally for listening on `popstate` events. We want\n * to provide this class in the most top injector that's used during bootstrapping.\n */\n\n\nfunction getSingleSpaExtraProviders() {\n  return [{\n    provide: SingleSpaPlatformLocation,\n    deps: [[new Inject(DOCUMENT)]]\n  }, {\n    provide: PlatformLocation,\n    useExisting: SingleSpaPlatformLocation\n  }];\n}\n\nconst defaultOptions = {\n  // Required options that will be set by the library consumer.\n  NgZone: null,\n  bootstrapFunction: null,\n  template: null,\n  // Optional options\n  Router: undefined,\n  domElementGetter: undefined,\n  updateFunction: () => Promise.resolve(),\n  bootstrappedModule: null\n};\nconst NG_DEV_MODE = typeof ngDevMode === 'undefined' || ngDevMode;\n\nfunction singleSpaAngular(userOptions) {\n  if (NG_DEV_MODE && typeof userOptions !== 'object') {\n    throw Error('single-spa-angular requires a configuration object');\n  }\n\n  const options = Object.assign(Object.assign({}, defaultOptions), userOptions);\n\n  if (NG_DEV_MODE && typeof options.bootstrapFunction !== 'function') {\n    throw Error('single-spa-angular must be passed an options.bootstrapFunction');\n  }\n\n  if (NG_DEV_MODE && typeof options.template !== 'string') {\n    throw Error('single-spa-angular must be passed options.template string');\n  }\n\n  if (NG_DEV_MODE && !options.NgZone) {\n    throw Error(`single-spa-angular must be passed the NgZone option`);\n  }\n\n  if (NG_DEV_MODE && options.Router && !options.NavigationStart) {\n    // We call `console.warn` except of throwing `new Error()` since this will not\n    // be a breaking change.\n    console.warn(`single-spa-angular must be passed the NavigationStart option`);\n  }\n\n  return {\n    bootstrap: bootstrap.bind(null, options),\n    mount: mount.bind(null, options),\n    unmount: unmount.bind(null, options),\n    update: options.updateFunction\n  };\n}\n\nfunction bootstrap(options, props) {\n  return __awaiter(this, void 0, void 0, function* () {\n    // Angular provides an opportunity to develop `zone-less` application, where developers\n    // have to trigger change detection manually.\n    // See https://angular.io/guide/zone#noopzone\n    if (options.NgZone === 'noop') {\n      return;\n    } // In order for multiple Angular apps to work concurrently on a page, they each need a unique identifier.\n\n\n    options.zoneIdentifier = `single-spa-angular:${props.name || props.appName}`; // This is a hack, since NgZone doesn't allow you to configure the property that identifies your zone.\n    // See https://github.com/PlaceMe-SAS/single-spa-angular-cli/issues/33,\n    // https://github.com/single-spa/single-spa-angular/issues/47,\n    // https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L144,\n    // and https://github.com/angular/angular/blob/a14dc2d7a4821a19f20a9547053a5734798f541e/packages/core/src/zone/ng_zone.ts#L257\n\n    options.NgZone.isInAngularZone = () => {\n      // @ts-ignore\n      return window.Zone.current._properties[options.zoneIdentifier] === true;\n    };\n\n    options.routingEventListener = () => {\n      options.bootstrappedNgZone.run(() => {// See https://github.com/single-spa/single-spa-angular/issues/86\n        // Zone is unaware of the single-spa navigation change and so Angular change detection doesn't work\n        // unless we tell Zone that something happened\n      });\n    };\n  });\n}\n\nfunction mount(options, props) {\n  return __awaiter(this, void 0, void 0, function* () {\n    getContainerElementAndSetTemplate(options, props);\n    const bootstrapPromise = options.bootstrapFunction(props);\n\n    if (NG_DEV_MODE && !(bootstrapPromise instanceof Promise)) {\n      throw Error(`single-spa-angular: the options.bootstrapFunction must return a promise, but instead returned a '${typeof bootstrapPromise}' that is not a Promise`);\n    }\n\n    const module = yield bootstrapPromise;\n\n    if (NG_DEV_MODE) {\n      if (!module || typeof module.destroy !== 'function') {\n        throw Error(`single-spa-angular: the options.bootstrapFunction returned a promise that did not resolve with a valid Angular module. Did you call platformBrowserDynamic().bootstrapModule() correctly?`);\n      }\n    }\n\n    const singleSpaPlatformLocation = module.injector.get(SingleSpaPlatformLocation, null);\n    const ngZoneEnabled = options.NgZone !== 'noop'; // The user has to provide `BrowserPlatformLocation` only if his application uses routing.\n    // So if he provided `Router` but didn't provide `BrowserPlatformLocation` then we have to inform him.\n    // Also `getSingleSpaExtraProviders()` function should be called only if the user doesn't use\n    // `zone-less` change detection, if `NgZone` is `noop` then we can skip it.\n\n    if (NG_DEV_MODE && ngZoneEnabled && options.Router && singleSpaPlatformLocation === null) {\n      throw new Error(`\n      single-spa-angular: could not retrieve extra providers from the platform injector. Did you call platformBrowserDynamic(getSingleSpaExtraProviders()).bootstrapModule()?\n    `);\n    }\n\n    const bootstrappedOptions = options;\n\n    if (ngZoneEnabled) {\n      const ngZone = module.injector.get(options.NgZone);\n      const zoneIdentifier = bootstrappedOptions.zoneIdentifier; // `NgZone` can be enabled but routing may not be used thus `getSingleSpaExtraProviders()`\n      // function was not called.\n\n      if (singleSpaPlatformLocation !== null) {\n        skipLocationChangeOnNonImperativeRoutingTriggers(module, options);\n      }\n\n      bootstrappedOptions.bootstrappedNgZone = ngZone;\n      bootstrappedOptions.bootstrappedNgZone['_inner']._properties[zoneIdentifier] = true;\n      window.addEventListener('single-spa:routing-event', bootstrappedOptions.routingEventListener);\n    }\n\n    bootstrappedOptions.bootstrappedModule = module;\n    return module;\n  });\n}\n\nfunction unmount(options) {\n  return Promise.resolve().then(() => {\n    if (options.routingEventListener) {\n      window.removeEventListener('single-spa:routing-event', options.routingEventListener);\n    }\n\n    options.bootstrappedModule.destroy();\n    options.bootstrappedModule = null;\n  });\n}\n\nfunction skipLocationChangeOnNonImperativeRoutingTriggers(module, options) {\n  if (!options.NavigationStart) {\n    // As discussed we don't do anything right now if the developer doesn't provide\n    // `options.NavigationStart` since this might be a breaking change.\n    return;\n  }\n\n  const router = module.injector.get(options.Router);\n  const subscription = router.events.subscribe(event => {\n    if (event instanceof options.NavigationStart) {\n      const currentNavigation = router.getCurrentNavigation(); // This listener will be set up for each Angular application\n      // that has routing capabilities.\n      // We set `skipLocationChange` for each non-imperative navigation,\n      // Angular router checks under the hood if it has to change\n      // the browser URL or not.\n      // If `skipLocationChange` is truthy then Angular router will not call\n      // `setBrowserUrl()` which calls `history.replaceState()` and dispatches `popstate` event.\n\n      if (currentNavigation.trigger !== 'imperative') {\n        currentNavigation.extras.skipLocationChange = true;\n        currentNavigation.extras.replaceUrl = false;\n      }\n    }\n  });\n  module.onDestroy(() => {\n    subscription.unsubscribe();\n  });\n}\n/**\n * The public api for consumers of single-spa-angular\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { enableProdMode, getSingleSpaExtraProviders, singleSpaAngular }; //# sourceMappingURL=single-spa-angular.mjs.map","map":null,"metadata":{},"sourceType":"module"}